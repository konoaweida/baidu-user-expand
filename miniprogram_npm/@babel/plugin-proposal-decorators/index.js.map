{"version":3,"sources":["index.js","transformer-legacy.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _helperPluginUtils = require(\"@babel/helper-plugin-utils\");\nvar _pluginSyntaxDecorators = require(\"@babel/plugin-syntax-decorators\");\nvar _helperCreateClassFeaturesPlugin = require(\"@babel/helper-create-class-features-plugin\");\nvar _transformerLegacy = require(\"./transformer-legacy.js\");\nvar _default = exports.default = (0, _helperPluginUtils.declare)((api, options) => {\n  api.assertVersion(7);\n  {\n    var {\n      legacy\n    } = options;\n  }\n  const {\n    version\n  } = options;\n  if (legacy || version === \"legacy\") {\n    return {\n      name: \"proposal-decorators\",\n      inherits: _pluginSyntaxDecorators.default,\n      visitor: _transformerLegacy.default\n    };\n  } else if (!version || version === \"2018-09\" || version === \"2021-12\" || version === \"2022-03\" || version === \"2023-01\" || version === \"2023-05\" || version === \"2023-11\") {\n    api.assertVersion(\"^7.0.2\");\n    return (0, _helperCreateClassFeaturesPlugin.createClassFeaturePlugin)({\n      name: \"proposal-decorators\",\n      api,\n      feature: _helperCreateClassFeaturesPlugin.FEATURES.decorators,\n      inherits: _pluginSyntaxDecorators.default,\n      decoratorVersion: version\n    });\n  } else {\n    throw new Error(\"The '.version' option must be one of 'legacy', '2023-11', '2023-05', '2023-01', '2022-03', or '2021-12'.\");\n  }\n});\n\n//# sourceMappingURL=index.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _core = require(\"@babel/core\");\nconst buildClassDecorator = _core.template.statement(`\n  DECORATOR(CLASS_REF = INNER) || CLASS_REF;\n`);\nconst buildClassPrototype = (0, _core.template)(`\n  CLASS_REF.prototype;\n`);\nconst buildGetDescriptor = (0, _core.template)(`\n    Object.getOwnPropertyDescriptor(TARGET, PROPERTY);\n`);\nconst buildGetObjectInitializer = (0, _core.template)(`\n    (TEMP = Object.getOwnPropertyDescriptor(TARGET, PROPERTY), (TEMP = TEMP ? TEMP.value : undefined), {\n        enumerable: true,\n        configurable: true,\n        writable: true,\n        initializer: function(){\n            return TEMP;\n        }\n    })\n`);\nconst WARNING_CALLS = new WeakSet();\nfunction applyEnsureOrdering(path) {\n  const decorators = (path.isClass() ? [path, ...path.get(\"body.body\")] : path.get(\"properties\")).reduce((acc, prop) => acc.concat(prop.node.decorators || []), []);\n  const identDecorators = decorators.filter(decorator => !_core.types.isIdentifier(decorator.expression));\n  if (identDecorators.length === 0) return;\n  return _core.types.sequenceExpression(identDecorators.map(decorator => {\n    const expression = decorator.expression;\n    const id = decorator.expression = path.scope.generateDeclaredUidIdentifier(\"dec\");\n    return _core.types.assignmentExpression(\"=\", id, expression);\n  }).concat([path.node]));\n}\nfunction applyClassDecorators(classPath) {\n  if (!hasClassDecorators(classPath.node)) return;\n  const decorators = classPath.node.decorators || [];\n  classPath.node.decorators = null;\n  const name = classPath.scope.generateDeclaredUidIdentifier(\"class\");\n  return decorators.map(dec => dec.expression).reverse().reduce(function (acc, decorator) {\n    return buildClassDecorator({\n      CLASS_REF: _core.types.cloneNode(name),\n      DECORATOR: _core.types.cloneNode(decorator),\n      INNER: acc\n    }).expression;\n  }, classPath.node);\n}\nfunction hasClassDecorators(classNode) {\n  var _classNode$decorators;\n  return !!((_classNode$decorators = classNode.decorators) != null && _classNode$decorators.length);\n}\nfunction applyMethodDecorators(path, state) {\n  if (!hasMethodDecorators(path.node.body.body)) return;\n  return applyTargetDecorators(path, state, path.node.body.body);\n}\nfunction hasMethodDecorators(body) {\n  return body.some(node => {\n    var _node$decorators;\n    return ((_node$decorators = node.decorators) == null ? void 0 : _node$decorators.length\n    );\n  });\n}\nfunction applyObjectDecorators(path, state) {\n  if (!hasMethodDecorators(path.node.properties)) return;\n  return applyTargetDecorators(path, state, path.node.properties.filter(prop => prop.type !== \"SpreadElement\"));\n}\nfunction applyTargetDecorators(path, state, decoratedProps) {\n  const name = path.scope.generateDeclaredUidIdentifier(path.isClass() ? \"class\" : \"obj\");\n  const exprs = decoratedProps.reduce(function (acc, node) {\n    let decorators = [];\n    if (node.decorators != null) {\n      decorators = node.decorators;\n      node.decorators = null;\n    }\n    if (decorators.length === 0) return acc;\n    if (node.computed) {\n      throw path.buildCodeFrameError(\"Computed method/property decorators are not yet supported.\");\n    }\n    const property = _core.types.isLiteral(node.key) ? node.key : _core.types.stringLiteral(node.key.name);\n    const target = path.isClass() && !node.static ? buildClassPrototype({\n      CLASS_REF: name\n    }).expression : name;\n    if (_core.types.isClassProperty(node, {\n      static: false\n    })) {\n      const descriptor = path.scope.generateDeclaredUidIdentifier(\"descriptor\");\n      const initializer = node.value ? _core.types.functionExpression(null, [], _core.types.blockStatement([_core.types.returnStatement(node.value)])) : _core.types.nullLiteral();\n      node.value = _core.types.callExpression(state.addHelper(\"initializerWarningHelper\"), [descriptor, _core.types.thisExpression()]);\n      WARNING_CALLS.add(node.value);\n      acc.push(_core.types.assignmentExpression(\"=\", _core.types.cloneNode(descriptor), _core.types.callExpression(state.addHelper(\"applyDecoratedDescriptor\"), [_core.types.cloneNode(target), _core.types.cloneNode(property), _core.types.arrayExpression(decorators.map(dec => _core.types.cloneNode(dec.expression))), _core.types.objectExpression([_core.types.objectProperty(_core.types.identifier(\"configurable\"), _core.types.booleanLiteral(true)), _core.types.objectProperty(_core.types.identifier(\"enumerable\"), _core.types.booleanLiteral(true)), _core.types.objectProperty(_core.types.identifier(\"writable\"), _core.types.booleanLiteral(true)), _core.types.objectProperty(_core.types.identifier(\"initializer\"), initializer)])])));\n    } else {\n      acc.push(_core.types.callExpression(state.addHelper(\"applyDecoratedDescriptor\"), [_core.types.cloneNode(target), _core.types.cloneNode(property), _core.types.arrayExpression(decorators.map(dec => _core.types.cloneNode(dec.expression))), _core.types.isObjectProperty(node) || _core.types.isClassProperty(node, {\n        static: true\n      }) ? buildGetObjectInitializer({\n        TEMP: path.scope.generateDeclaredUidIdentifier(\"init\"),\n        TARGET: _core.types.cloneNode(target),\n        PROPERTY: _core.types.cloneNode(property)\n      }).expression : buildGetDescriptor({\n        TARGET: _core.types.cloneNode(target),\n        PROPERTY: _core.types.cloneNode(property)\n      }).expression, _core.types.cloneNode(target)]));\n    }\n    return acc;\n  }, []);\n  return _core.types.sequenceExpression([_core.types.assignmentExpression(\"=\", _core.types.cloneNode(name), path.node), _core.types.sequenceExpression(exprs), _core.types.cloneNode(name)]);\n}\nfunction decoratedClassToExpression({\n  node,\n  scope\n}) {\n  if (!hasClassDecorators(node) && !hasMethodDecorators(node.body.body)) {\n    return;\n  }\n  const ref = node.id ? _core.types.cloneNode(node.id) : scope.generateUidIdentifier(\"class\");\n  return _core.types.variableDeclaration(\"let\", [_core.types.variableDeclarator(ref, _core.types.toExpression(node))]);\n}\nconst visitor = {\n  ExportDefaultDeclaration(path) {\n    const decl = path.get(\"declaration\");\n    if (!decl.isClassDeclaration()) return;\n    const replacement = decoratedClassToExpression(decl);\n    if (replacement) {\n      const [varDeclPath] = path.replaceWithMultiple([replacement, _core.types.exportNamedDeclaration(null, [_core.types.exportSpecifier(_core.types.cloneNode(replacement.declarations[0].id), _core.types.identifier(\"default\"))])]);\n      if (!decl.node.id) {\n        path.scope.registerDeclaration(varDeclPath);\n      }\n    }\n  },\n  ClassDeclaration(path) {\n    const replacement = decoratedClassToExpression(path);\n    if (replacement) {\n      const [newPath] = path.replaceWith(replacement);\n      const decl = newPath.get(\"declarations.0\");\n      const id = decl.node.id;\n      const binding = path.scope.getOwnBinding(id.name);\n      binding.identifier = id;\n      binding.path = decl;\n    }\n  },\n  ClassExpression(path, state) {\n    const decoratedClass = applyEnsureOrdering(path) || applyClassDecorators(path) || applyMethodDecorators(path, state);\n    if (decoratedClass) path.replaceWith(decoratedClass);\n  },\n  ObjectExpression(path, state) {\n    const decoratedObject = applyEnsureOrdering(path) || applyObjectDecorators(path, state);\n    if (decoratedObject) path.replaceWith(decoratedObject);\n  },\n  AssignmentExpression(path, state) {\n    if (!WARNING_CALLS.has(path.node.right)) return;\n    path.replaceWith(_core.types.callExpression(state.addHelper(\"initializerDefineProperty\"), [_core.types.cloneNode(path.get(\"left.object\").node), _core.types.stringLiteral(path.get(\"left.property\").node.name || path.get(\"left.property\").node.value), _core.types.cloneNode(path.get(\"right.arguments\")[0].node), _core.types.cloneNode(path.get(\"right.arguments\")[1].node)]));\n  },\n  CallExpression(path, state) {\n    if (path.node.arguments.length !== 3) return;\n    if (!WARNING_CALLS.has(path.node.arguments[2])) return;\n    if (path.node.callee.name !== state.addHelper(\"defineProperty\").name) {\n      return;\n    }\n    path.replaceWith(_core.types.callExpression(state.addHelper(\"initializerDefineProperty\"), [_core.types.cloneNode(path.get(\"arguments\")[0].node), _core.types.cloneNode(path.get(\"arguments\")[1].node), _core.types.cloneNode(path.get(\"arguments.2.arguments\")[0].node), _core.types.cloneNode(path.get(\"arguments.2.arguments\")[1].node)]));\n  }\n};\nvar _default = exports.default = visitor;\n\n//# sourceMappingURL=transformer-legacy.js.map\n"]}